/**
 * Core type definitions for finite automata (DFA/NFA)
 *
 * Design decisions:
 * - State IDs are auto-incremented integers (0, 1, 2, ...)
 * - Sets used for states, alphabet, and transition destinations (ensures uniqueness)
 * - Immutable design: operations return NEW automatons, never mutate existing ones
 * - Engine layer owns IDs, UI layer owns labels (separation of concerns)
 */

/**
 * A transition from one state to another on a given symbol
 *
 * Design notes:
 * - State IDs are integers (auto-generated by addState())
 * - `to` is a Set for NFA-compatibility
 *   - DFA: set with exactly 1 element, e.g., new Set([1])
 *   - NFA: set with multiple elements, e.g., new Set([1, 2])
 * - `symbol` is null for ε-transitions (epsilon/empty transitions in NFAs)
 * - For DFAs, symbol should never be null
 */
export type Transition = {
  /** Source state ID (integer) */
  from: number;

  /**
   * Destination state IDs (Set for NFA-compatibility)
   * DFA: Set with exactly 1 element
   * NFA: Set with 0+ elements
   */
  to: Set<number>;

  /**
   * Input symbol that triggers this transition
   * null = ε-transition (empty/epsilon transition for NFAs)
   * For DFAs, this should never be null
   */
  symbol: string | null;
};

/**
 * A finite automaton (deterministic or non-deterministic)
 *
 * Example DFA that accepts strings ending in "01":
 * {
 *   type: 'DFA',
 *   states: new Set([0, 1, 2]),
 *   alphabet: new Set(['0', '1']),
 *   transitions: [
 *     { from: 0, to: new Set([1]), symbol: '0' },
 *     { from: 0, to: new Set([0]), symbol: '1' },
 *     { from: 1, to: new Set([1]), symbol: '0' },
 *     { from: 1, to: new Set([2]), symbol: '1' },
 *     { from: 2, to: new Set([1]), symbol: '0' },
 *     { from: 2, to: new Set([0]), symbol: '1' },
 *   ],
 *   startState: 0,
 *   acceptStates: new Set([2]),
 *   nextStateId: 3
 * }
 */
export type Automaton = {
  /** Type of automaton: 'DFA' or 'NFA' */
  type: 'DFA' | 'NFA';

  /** Set of all state IDs (integers, auto-generated) */
  states: Set<number>;

  /** Input alphabet (Set of symbols, ensures uniqueness) */
  alphabet: Set<string>;

  /** All transitions in the automaton */
  transitions: Transition[];

  /**
   * ID of the start state (integer)
   * Always set - createAutomaton() creates initial state 0 as start
   */
  startState: number;

  /** Set of accepting/final state IDs (must be subset of states) */
  acceptStates: Set<number>;

  /** Next state ID to assign (auto-increment counter) */
  nextStateId: number;
};

/**
 * Result of a single simulation step
 * Tracks the current state during execution
 */
export type SimulationStep = {
  /** Current state ID after processing this symbol */
  currentState: number;

  /**
   * The input symbol that was just processed
   * null if this is the initial step (before processing any input)
   */
  symbolProcessed: string | null;

  /** Remaining input string to process */
  remainingInput: string;
};

/**
 * A simulation in progress or completed
 * Tracks the current state of execution through the automaton
 *
 * Design notes:
 * - currentStates is a Set for NFA-compatibility (DFA uses single element)
 * - steps array tracks execution history
 * - Use isFinished() to check if simulation is complete
 * - Use isAccepted() to check if finished in accept state
 */
export type Simulation = {
  /** The automaton being simulated */
  automaton: Automaton;

  /**
   * Current active states
   * DFA: Set with exactly 1 element
   * NFA: Set with 0+ elements (after epsilon closure)
   */
  currentStates: Set<number>;

  /** Remaining input string to process */
  remainingInput: string;

  /** Execution history (all steps taken so far) */
  steps: SimulationStep[];

  /** Original input string (for reference) */
  input: string;
};
